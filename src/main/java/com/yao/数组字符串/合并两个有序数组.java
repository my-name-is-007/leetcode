package com.yao.数组字符串;

public class 合并两个有序数组 {

    //给你,
//另有.
//
//
//为了应对这种情况，nums1 的初始长度为 m + n, 其中前 m 个元素表示
//应合并的元素，后 n 个元素为 0 ，应忽略。nums2 的长度为 n.

    /**
     * 两个按 非递减顺序 排列的整数数组 nums1 和 nums2
     * 两个整数 m 和 n ，分别表示 nums1 和 nums2 中的元素数目
     * 请你 合并 nums2 到 nums1 中, 使合并后的数组同样按 非递减顺序 排列.
     *
     * 注意：最终, 合并后数组不应由函数返回, 而是存储在数组 nums1 中.
     *
     * 这里要注意的就是, 两者数组都是有序的, 而且要放到数组1里面, 所以可以从后续遍历两个数组, 然后都放到第一个数组的前面
     */
    public void merge(int[] nums1, int m, int[] nums2, int n) {
        //指针: 数组1最后一个位置.

        int idx1 = m - 1;
        int idx2 = n - 1;

        int curIdx = nums1.length - 1;

        while(idx1 >= 0 && idx2 >= 0){
            nums1[curIdx--] = nums1[idx1] >= nums2[idx2] ? nums1[idx1--] : nums2[idx2--];
        }

        /**
         * 循环退出的条件: 数组1搬完 或者 数组2搬完
         *     1. 数组1搬完 且 数组2搬完: 不用碰
         *     2. 数组1搬完 且 数组2没有搬完
         *            把数组2没搬完的放到数组1前面即可
         *     3. 数组2搬完 且 数组1搬完: 不用碰
         *     4. 数组2搬完 且 数组1没有搬完
         *            数组1前面的也不用碰, 因为即使碰了, 也是把它们放到原来的位置
         */
        if(idx2 >= 0){
            for(int i = 0; i < idx2; i++) {
                nums1[i] = nums2[i];
            }
        }
    }

}
